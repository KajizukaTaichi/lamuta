# Lamuta言語仕様書

この文書はプログラミング言語Lamutaの仕様を纏めたものである。
まだドラフトであり厳密な定義でなく、処理系がこの仕様に従って動作する保証はない。
飽くまで参考程度に捉えてくれると嬉しい。貢献も歓迎している。

もしLamutaの仕組みを本格的に詳しく知りたければ、[処理系のソースコード](src/main.rs)をご覧いただきたい。

## 型システム

### 値

値とは、プログラムが評価された結果となるデータである。

#### 数値(nunber)
64ビットの浮動小数点数。

#### 文字列(string)
リテラルはダブルクォートで囲んで記述する。
特殊文字はバックスラッシュでエスケープする必要がある。

結合するには、プラス(`+`)演算子で、両辺に結合したい文字列を書く。
リピートするには、アスタリスク(`*`)演算子で、左辺にその文字列、右辺にリピート回数を数値で指定する。

リストに変換すると、1文字ずつに分割される。
数値への変換は、データ次第で失敗する可能性もある。if文と組み合わせて活用すること。

#### ラムダ抽象(function)
ラムダ記号もしくはバックスラッシュの後に仮引数と関数本体の式をドットで区切って書く。
```ebnf
"λ" | "\", arg, ".", expr
```

また、糖衣構文として命令型の記法も存在する：
```ebnf
"fn(", arg, { ",", arg }, "->", statement, ")"
```

糖衣構文では複数の引数を扱えるように見えるが、ラムダ計算に忠実に1つの引数しか取れない仕様である。
内部的にカリー化処理を施している。

#### 構造体
構造体はブロックと区別するため先頭にアットマークを付けて波括弧で囲む。
キーと値の組みをコロンで区切り、複数の場合はそれをカンマで区切る。
なお、キーは文字列型の値である必要がある。
```ebnf
"@{", expr, { ",", expr }, "}"
```

結合するには、プラス(`+`)演算子で、両辺に結合したい構造体を書く。キーが競合する場合は、右辺が優先される。
リストに変換すると、キーと値の組みの要素数2のリストを持つリストとなる。

## 式
式の項や演算子はスペースで区切る。
```ebnf
term , { " " , term }
```
　
### 演算子

**二項演算子(infix)は**：

加算(`+`)、減算(`-`)、乗算(`*`)、除算(`/`)、余剰(`%`)、べき乗(`^`)の四則演算、
等価(`==`)、非等価(`!=`)、大なり(`>`)、大なり等価(`>=`)、小なり(`<`)、小なり等価(`<=`)の比較演算、論理積(`&`)、論理和(`|`)の論理演算、
代入(`:=`)、加算代入(`+=`)、減算代入(`-=`)、乗算代入(`*=`)、除算代入(`/=`)、余剰代入(`%=`)、べき乗代入(`^=`)の代入演算、
関数を繋げるパイプライン(`|>`)、リストや構造体へのアクセス演算子(`::`)、範囲生成(`~`)がある。


**単項演算子(prefix)は**：

論理否定(`!`)、参照(`&`)、参照外し(`*`)、マイナス(`-`)がある。
これはスペースで区切る必要はなく、項の前に付ければ良い。

### 関数適用
式の中に関数(function型)と引数をスペースで区切って書く。
パース時に演算子として認識できない場合に関数適用と解釈される。
```ebnf
expr, " ", expr
```

また、糖衣構文として命令型の記法も存在する：
```ebnf
bind, "(", expr, { ",", expr }, ")"
```

複数引数は、そのまま後の引数を繋げて書けば、カリー化された関数の内部が返り、それが関数適用される。
引数はベータ簡約で渡される。よって、引数は不変である。

### ブロック
ブロックは波括弧で囲み、文をセミコロンで区切る。
最後に評価された文の戻り値がブロックのそれとなる。
```ebnf
"{", statement, { ";", statement }, "}"
```
