const len: function = λl.{ let i = 0; for _ in (l as list) { let i = (i + 1) }; i };
const join: function = λa.λb.{ let result = ""; let index = 0; for i in a { let index = (index + 1); let result = (result + (i as text) + { if (index == (len a)) "" else b }) }; result };
const replace: function = λt.λb.λa.{ let result = t; let index = ((find t) b); ((result :: (index ~ ((len b) + 1))) := a); result }
const set: function = λl.λi.λv.{ let before = ((slice l) (range i)); let after = ((slice l) (range [(i + 1), (len l)])); (before + { if (type l == text) v else [v] } + after) };
const filter: function = λf.λl.{ let result = []; for i in l { if (f i) { let result = (result + [i]) } }; result };
const reduce: function = λf.λl.{ let result = (l :: 0); for i in ((slice l) (range [1, (len l)])) { let result = (f result i) }; result };
const map: function = λf.λl.{ let result = []; for i in l { let result = (result + [(f i)]) }; result };
const find: function = λt.λq.{ let result = null; let index = 0; while (index < ((len t) - (len q) + 1)) { let item = ((slice t) (range [index, (len q + index)])); if (item == q) { let result = index }; let index = (index + 1) }; if (result == null) { fault } else result };
const slice: function = λl.λs.{ let result = { if (type l == text) "" else [] }; for index in (s as list) { let result = (result + { if (type l == text) (l :: index) else [(l :: index)] }) }; result };
const compose: function = λf.λg.λx.(f (g x));
