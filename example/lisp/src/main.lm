let eval = λe.λp.{
    let env = e;
    match (p :: "type") {
        "expr" → {
            let code = [];
            for i in (p :: "value") {
                let code = code + [eval env i];
            };
            if (code :: 0 :: "type" == "function") {
                let func = (code :: 0 :: "value");
                func (slice code (range [1, len code]))
            } else {
                fault
            }
        },
        "symbol" → env :: (p :: "value"),
        _ → p
    }
};

let getNumber = λx.{
    if (x :: "type" == "number") (
        x :: "value" as Γnumber
    ) else {
        fault
    }
};

let parse = λsource.{
    if (source :: 0 == "(" & (source :: (len source - 1) == ")")) {
        let inner = slice source (range [1, len source - 1]);
        let result = [];
        for i in (tokenize inner) {
            let result = result + [parse i];
        };
        { "type": "expr", "value": result }
    } else {
        if (source as Γnumber) { "type": "number", value: it }
        else { "type": "symbol", "value": source }
    }
};

let tokenize = λsource.{
    let tokens = [];
    let current = "";
    let nest = 0;

    for c in source {
        match c {
            "(" | "[" | "{" → {
                let current = current + c;
                let nest = nest + 1;
            },
            ")" | "]" | "}" → {
                let current = current + c;
                let nest = nest - 1;
            },
            " " | "　" → {
                if (nest == 0) {
                    if (current != "") {
                        let tokens = tokens + [current];
                        let current = "";
                    }
                } else {
                    let current = current + c;
                }
            },
            _ → {
                let current = current + c;
            }
        }
    };

    if (current != "") {
        let tokens = tokens + [current];
    };

    tokens
};

let env = {
    "+": { "type": "function", "value": λl.{ "type": "number", "value": (reduce λa.λb.(a + b) (map getNumber l)) } },
    "-": { "type": "function", "value": λl.{ "type": "number", "value": (reduce λa.λb.(a - b) (map getNumber l)) } },
    "*": { "type": "function", "value": λl.{ "type": "number", "value": (reduce λa.λb.(a * b) (map getNumber l)) } },
    "/": { "type": "function", "value": λl.{ "type": "number", "value": (reduce λa.λb.(a / b) (map getNumber l)) } }
};

let main = λ_.{
    print "Lamuta Lisp";
    let flag = 1;
    while (flag == 1) {
        let entered = (input ">>> ");
        if (entered == "") {
            let flag = 0;
        } else {
            if (find entered "=") {
                let name = slice entered (range [0, it]);
                let expr = slice entered (range [it + 1, len entered]);
                let env = env + { (tokenize name :: 0): eval env (parse (tokenize expr :: 0)) };
            } else {
                print eval env (parse entered);
            }
        }
    }
};

main run
