load "docs/lib/std.lm";

const specialForms: list = ["define", "if", "eval"];
const AST: struct = @{
    "type": null,
    "value": null,
    "get": fn(sig, this ->
        if (this.type == (sig as text)) {
            this.value as sig
        } else {
            fault sig as text + ", " + this.type
        }
    ),
    "asText": fn(this ->
        match this.type {
            "number" => this.value as text,
            "text" => "\"" + this.value + "\"",
            "symbol" => this.value,
            "bool" => { if (this.value == 1) "true" else "false" },
            "list" => "\'(" + (join (map fn(x -> x.asText x) this.value) " ") + ")"
        }
    )
};

let evaluate = fn(e, p ->
    let scope = e;
    match p.type {
        "expr" => {
            let code = [];
            for i in p.value {
                let [scope, value] = evaluate scope i;
                code += [value];
            };
            if (code[0].type == "function") {
                let func: function = code[0].value;
                [scope, func code[1 ~ (len code)]]
            } else {
                fault
            }
        },
        "specialForm" => {
            let code: list = p.value;
            match (code[0].value) {
                "define" => {
                    let name = code[1].value;
                    let expr = code[2];
                    let [scope, value] = evaluate scope expr;
                    scope += @{ name: value };
                    [scope, value]
                },
                "if" => {
                    let [_, expr, thenCode, elseCode] = code;
                    let [scope, value] = evaluate scope expr;
                    evaluate scope {
                        if (0 != value.value != "")
                            thenCode
                        else
                            elseCode
                    }
                },
                "eval" => {
                    let expr = AST.get list code[1];
                    evaluate scope (AST + @{
                        "type": {
                            if (specialForms `find` [expr[0].value])
                                "specialForm"
                            else
                                "expr"
                        },
                        "value": expr
                    })
                }
            }
        },
        "symbol" => [scope, { if (scope :: p.value) it else p }],
        _ => [scope, p]
    }
);

let parse = fn(source ->
    if (source[0] == "(" & (source[len source - 1] == ")")) {
        let inner = source[1 ~ (len source - 1)];
        let result = [];
        for i in (tokenize inner) {
            let result = result + [parse i];
        };
        if (specialForms `find` [result[0].value]) {
            AST + @{ "type": "specialForm", "value": result }
        } else {
            AST + @{ "type": "expr", "value": result }
        }
    } else {
        if (source[0 ~ 2] == "\'(" & (source[len source - 1] == ")")) {
            let inner = source[2 ~ (len source - 1)];
            let result = [];
            for i in (tokenize inner) {
                let result = result + [parse i];
            };
            AST + @{ "type": "list", "value": result }
        } else {
            if (source[0] == "\"" & (source[len source - 1] == "\"")) {
                let inner = source[1 ~ (len source - 1)];
                AST + @{ "type": "text", "value": inner }
            } else {
                if (source as number) AST + @{ "type": "number", "value": it }
                else AST + @{ "type": "symbol", "value": source }
            }
        }
    }
);

let tokenize = fn(source ->
    let tokens = [];
    let current = "";
    let nest = 0;
    let quote = 0;

    for c in (source as list) {
        match c {
            "(" | "[" | "{" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest + 1;
                }
            },
            ")" | "]" | "}" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest - 1;
                }
            },
            " " | "　" => {
                if ((nest == 0) & (quote == 0)) {
                    if (current != "") {
                        let tokens = tokens + [current];
                        let current = "";
                    }
                } else {
                    let current = current + c;
                }
            },
            "\"" => {
                let quote = { if (quote == 1) 0 else 1 };
                let current = current + c;
            },
            _ => {
                let current = current + c;
            }
        }
    };

    if (current != "") {
        let tokens = tokens + [current];
    };

    tokens
);

let scope = @{
    "+": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a + b) (map (AST.get number) l)
        })
    },
    "-": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a - b) (map (AST.get number) l)
        })
    },
    "*": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a * b) (map (AST.get number) l)
        })
    },
    "/": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a / b) (map (AST.get number) l)
        })
    },
    "%": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a % b) (map (AST.get number) l)
        })
    },
    "^": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a ^ b) (map (AST.get number) l)
        })
    },
    "=": @{
        "type": "function",
        "value": λl.{
            let result = AST + @{ "type": "bool" };
            result.value := { if (reduce λa.λb.(a == b) l) 1 else 0 };
            result
        }
    },
    "concat": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "text",
            "value": reduce λa.λb.(a + b) (map (AST.get text) l)
        })
    }
};

let main = λ_.{
    print "Lamuta Lisp\n";
    let flag = 1;
    while (flag == 1) {
        let entered = input ">>> ";
        if (entered == "") {
            let flag = 0;
        } else {
            let [scope, value] =  evaluate(scope, parse entered);
            print value.asText value, "\n";
        }
    }
};

main _
