load std;

const specialForms: list = ["define", "if", "eval", "lambda"];
const AST: struct = @{
    "type": null,
    "value": null,
    "get": fn(sig, this ->
        if (this.type == (sig as text))
            this.value
        else {
            fault sig as text + ", " + this.type
        }
    ),
    "asText": fn(this ->
        match this.type {
            "number" => this.value as text,
            "text" => "\"" + this.value + "\"",
            "symbol" => this.value,
            "bool" => { if (this.value == 1) "true" else "false" },
            "list" => "\'(" + (join (map fn(x -> x.asText x) this.value) " ") + ")",
            "function" => "<Function>"
        }
    )
};

let evaluate = fn(e, p ->
    let scope = e;
    match p.type {
        "expr" => {
            let code = [];
            for i in p.value {
                let [scope, value] = evaluate scope i;
                code += [value];
            };
            if (code[0].type == "function") {
                let func: function = code[0].value;
                [scope, func code[1 ~ (len code)]]
            } else {
                fault
            }
        },
        "specialForm" => {
            let code: list = p.value;
            match (code[0].value) {
                "define" => {
                    let name = code[1].value;
                    let expr = code[2];
                    let [scope, value] = evaluate scope expr;
                    scope += @{ name: value };
                    [scope, value]
                },
                "if" => {
                    let [_, expr, thenCode, elseCode] = code;
                    let [scope, value] = evaluate scope expr;
                    evaluate scope {
                        if (0 != value.value != "")
                            thenCode
                        else
                            elseCode
                    }
                },
                "eval" => {
                    let [scope, expr] = evaluate(scope, code[1]);
                    let expr = AST.get list expr;
                    evaluate scope (AST + @{
                        "type": {
                            if (specialForms `find` [expr[0].value])
                                "specialForm"
                            else
                                "expr"
                        },
                        "value": expr
                    })
                },
                "lambda" => {
                    let [_, args, body] = code;
                    let args = map (AST.get symbol) args.value;
                    let funcObj = fn(args, body -> AST + @{
                        "type": "function",
                        "value": λl.{
                            let funcScope = scope;
                            for [name, value] in zip(args, l) {
                                funcScope += @{ name: value }
                            };
                            evaluate funcScope body :: 1
                        }
                    });
                    [scope, funcObj args body]
                }
            }
        },
        "symbol" => [scope, { if (scope :: p.value) it else p }],
        _ => [scope, p]
    }
);

let parse = fn(source ->
    if (source[0] == "(" & (source[len source - 1] == ")")) {
        let inner = source[1 ~ (len source - 1)];
        let result = [];
        for i in (tokenize inner) {
            let result = result + [parse i];
        };
        if (specialForms `find` [result[0].value]) {
            AST + @{ "type": "specialForm", "value": result }
        } else {
            AST + @{ "type": "expr", "value": result }
        }
    } else if (source[0 ~ 2] == "\'(" & (source[len source - 1] == ")")) {
        let inner = source[2 ~ (len source - 1)];
        let result = [];
        for i in (tokenize inner) {
            let result = result + [parse i];
        };
        AST + @{ "type": "list", "value": result }
    } else if (source[0] == "\"" & (source[len source - 1] == "\"")) {
        let inner = source[1 ~ (len source - 1)];
        AST + @{ "type": "text", "value": inner }
    } else if (source == "true") {
        AST + @{ "type": "bool", "value": 1 }
    } else if (source == "false") {
        AST + @{ "type": "bool", "value": 0 }
    } else {
        if (source as number)
            AST + @{ "type": "number", "value": it }
        else
            AST + @{ "type": "symbol", "value": source }
    }
);

let tokenize = fn(source ->
    let tokens = [];
    let current = "";
    let nest = 0;
    let quote = 0;

    for c in (source as list) {
        match c {
            "(" | "[" | "{" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest + 1;
                }
            },
            ")" | "]" | "}" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest - 1;
                }
            },
            " " | "　" => {
                if ((nest == 0) & (quote == 0)) {
                    if (current != "") {
                        let tokens = tokens + [current];
                        let current = "";
                    }
                } else {
                    let current = current + c;
                }
            },
            "\"" => {
                let quote = { if (quote == 1) 0 else 1 };
                let current = current + c;
            },
            _ => {
                let current = current + c;
            }
        }
    };

    if (current != "") {
        let tokens = tokens + [current];
    };

    tokens
);

let scope = @{
    "+": AST + @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce (`+`) (map (AST.get number) l)
        })
    },
    "-": AST + @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce (`-`) (map (AST.get number) l)
        })
    },
    "*": AST + @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce (`*`) (map (AST.get number) l)
        })
    },
    "/": AST + @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce (`/`) (map (AST.get number) l)
        })
    },
    "%": AST + @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce (`%`) (map (AST.get number) l)
        })
    },
    "^": AST + @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce (`^`) (map (AST.get number) l)
        })
    },
    "=": AST + @{
        "type": "function",
        "value": λl.{
            let result = AST + @{ "type": "bool" };
            result.value := { if (reduce (`==`) l) 1 else 0 };
            result
        }
    },
    "concat": AST + @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "text",
            "value": reduce (`+`) (map (AST.get text) l)
        })
    }
};

let main = λ_.{
    print "Lamuta Lisp\n";
    let flag = 1;
    while (flag == 1) {
        let entered = input ">>> ";
        if (entered == ":q") {
            let flag = 0;
        } else if evaluate(scope, parse entered) {
            let [scope, value] = it;
            print value.asText value, "\n";
        } else {
            print "Error!\n";
        }
    }
};

main _
