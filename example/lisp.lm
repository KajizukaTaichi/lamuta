load "docs/lib/std.lm";

const specialForms: list = ["define"];
const AST: struct = @{
    "type": null,
    "value": null,
    "get": fn(sig, self ->
        if (self.type == (sig as text)) {
            self.value as sig
        } else {
            fault
        }
    )
};

let evaluate = fn(e, p ->
    let scope = e;
    match p.type {
        "expr" => {
            let code = [];
            for i in p.value {
                let [scope, value] = evaluate scope i;
                code += [value];
            };
            if (code[0].type == "function") {
                let func: function = code :: 0 :: "value";
                [scope, func code[1 ~ (len code)]]
            } else {
                fault
            }
        },
        "specialForm" => {
            let code: list = p.value;
            match (code[0].value) {
                "define" => {
                    let name = code[1].value;
                    let expr = code[2];
                    let [scope, value] = evaluate scope expr;
                    scope += @{ name: value };
                    [scope, value]
                }
            }
        },
        "symbol" => [scope, { if (scope :: p.value) it else p }],
        _ => [scope, p]
    }
);

let parse = fn(source ->
    if (source :: 0 == "(" & (source :: (len source - 1) == ")")) {
        let inner = source :: (1 ~ (len source - 1));
        let result = [];
        for i in (tokenize inner) {
            let result = result + [parse i];
        };
        if (specialForms `find` [result :: 0 :: "value"]) {
            AST + @{ "type": "specialForm", "value": result }
        } else {
            AST + @{ "type": "expr", "value": result }
        }
    } else {
        if (source :: 0 == "\'") {
            let inner = source :: (2 ~ (len source - 1));
            let result = [];
            for i in (tokenize inner) {
                let result = result + [parse i];
            };
            AST + @{ "type": "list", "value": result }
        } else {
            if (source :: 0 == doubleQuote & (source :: (len source - 1) == doubleQuote)) {
                let inner = source :: (1 ~ (len source - 1));
                AST + @{ "type": "text", "value": inner }
            } else {
                if (source as number) AST + @{ "type": "number", "value": it }
                else AST + @{ "type": "symbol", "value": source }
            }
        }
    }
);

let tokenize = fn(source ->
    let tokens = [];
    let current = "";
    let nest = 0;
    let quote = 0;

    for c in (source as list) {
        match c {
            "(" | "[" | "{" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest + 1;
                }
            },
            ")" | "]" | "}" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest - 1;
                }
            },
            " " | "　" => {
                if ((nest == 0) & (quote == 0)) {
                    if (current != "") {
                        let tokens = tokens + [current];
                        let current = "";
                    }
                } else {
                    let current = current + c;
                }
            },
            "\"" => {
                let quote = { if (quote == 1) 0 else 1 };
                let current = current + c;
            },
            _ => {
                let current = current + c;
            }
        }
    };

    if (current != "") {
        let tokens = tokens + [current];
    };

    tokens
);

let scope = @{
    "+": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a + b) (map (AST.get number) l)
        })
    },
    "-": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a - b) (map (AST.get number) l)
        })
    },
    "*": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a * b) (map (AST.get number) l)
        })
    },
    "/": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a / b) (map (AST.get number) l)
        })
    },
    "%": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a % b) (map (AST.get number) l)
        })
    },
    "^": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "number",
            "value": reduce λa.λb.(a ^ b) (map (AST.get number) l)
        })
    },
    "concat": @{
        "type": "function",
        "value": λl.(AST + @{
            "type": "text",
            "value": reduce λa.λb.(a + b) (map (AST.get text) l)
        })
    },
    "eval": @{
        "type": "function",
        "value": λl.{
            let expr = getList l[0];
            evaluate scope (AST + @{ "type": "expr", "value": expr })
        }
    }
};

let main = λ_.{
    print "Lamuta Lisp\n";
    let flag = 1;
    while (flag == 1) {
        let entered = input ">>> ";
        if (entered == "") {
            let flag = 0;
        } else {
            let [scope, value] =  evaluate(scope, parse entered);
            print value, "\n";
        }
    }
};

main _
