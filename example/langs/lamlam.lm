load std;
const SPACE: list = [" ", "　", "\n", "\t", "\r"];

let evalExpr = fn(e, x ->
    let [scope, ast] = [e, x];
    match (type ast) {
        #Print => {
            for i in ast.value {
                let [scope, val] = evalExpr scope i;
                print valueShow val;
            };
            [scope, @{ "class": #Value, "value": null }]
        },
        #Let => {
            let name = ast.value[0];
            let [scope, val] = evalExpr scope ast.value[1];
            if (type name == #Symbol) {
                scope[name.value] := val;
                [scope, val]
            } else if (type name == #List) {
                for item in zip(name.value, val.value) {
                    let [scope, _] = evalExpr scope @{ "class": #Let, "value": item }
                };
                [scope, val]
            } else {
                fault "the program is not able to parse. check out is the syntax correct"
            }
        },
        #If => {
            if { let [scope, cond] = evalExpr scope ast.value[0] }
                evalExpr scope ast.value[1]
            else if ast.value[2]
                evalExpr scope it
            else
                [scope, @{ "class": #Value, "value": null }]
        },
        #For => {
            let [counter, iter, body] = ast.value;
            let result = @{ "class": #Value, "value": null };
            let [scope, iter] = evalExpr scope iter;
            for item in iter.value {
                let [scope, _] = evalExpr scope @{ "class": #Let, "value": [counter, item] };
                let [scope, result] = evalExpr scope body;
            };
            [scope, result]
        },
        #Block => {
            let result = @{ "class": #Value, "value": null };
            for i in ast.value {
                [scope, result] := evalExpr(scope, i);
            };
            [scope, result]
        },
        #Symbol => {
            [scope, scope[ast.value]]
        },
        #List => {
            let result = [];
            for i in ast.value {
                [scope, val] := evalExpr(scope, i);
                result += [val]
            };
            [scope, @{ "class": #Value, "value": result }]
        },
        #Apply => {
            let [[scope, func], [scope, value]] = map (evalExpr scope) ast.value;
            let [[arg, body], funcScope] = [func.value, scope];
            let body = betaReduct(arg, value, body);
            [scope, evalExpr funcScope body :: 1]
        },
        #Add => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value + b.value }]
        },
        #Sub => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope,@{ "class": #Value, "value": a.value - b.value }]
        },
        #Mul => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value * b.value }]
        },
        #Div => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value / b.value }]
        },
        #Mod => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value % b.value }]
        },
        #Pow => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value ^ b.value }]
        },
        #Equal => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value == b.value }]
        },
        #As => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value as b.value }]
        },
        #Access => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": (a.value :: b.value) }]
        },
        _ => [scope, ast]
    }
);

let betaReduct = fn(x, y, z ->
    let [from, to, ast] = [x, y, z];
    match (type ast) {
        #Let => {
            @{ "class": #Let, "value": [ast.value[0], betaReduct from to ast.value[1]] }
        },
        #Add | #Sub | #Mul | #Div | #Mod | #Pow
        | #Apply | #Equal | #Block | #Print | #If | #For => {
            @{ "class": type ast, "value": map (betaReduct from to) ast.value }
        },
        #Symbol => { if (ast.value == from) to else ast },
        #Lambda => {
            let [args, body] = ast.value;
            @{
                "class": #Lambda,
                "value": [args, {
                    if (args == from)
                        body
                    else
                        (betaReduct from to) body
                }]
            }
        },
        _ => ast
    }
);

let parseBlock = fn(source ->
    let [token, block] = [trim source, []];
    for line in (tokenize [";"] token) {
        block += [parseStmt line]
    };
    @{ "class": #Block, "value": block }
);

let parseStmt = fn(source ->
    let token = trim source;
    if (token["print"] == (0 ~ 5)) {
        let token = tokenize [","] (token - "print");
        @{ "class": #Print, "value": map parseExpr token }
    } else if (token["let"] == (0 ~ 3)) {
        let token = token - "let" / "=";
        @{ "class": #Let, "value": map parseExpr [token[0], join token[1 ~ len(token)] "="] }
    } else if (token["if"] == (0 ~ 2)) {
        let token = tokenize SPACE (token - "if");
        @{
            "class": #If,
            "value": {
                if (token :: ["else"]) {
                    let index = it as list :: 0;
                    [
                        parseExpr token[0],
                        parseExpr (join token[1 ~ index] SPACE[0]),
                        parseBlock (join token[index + 1 ~ len(token)] SPACE[0])
                    ]
                } else [
                    parseExpr token[0],
                    parseExpr (join token[1 ~ len(token)] SPACE[0])
                ]
            }
        }
     } else if (token["for"] == (0 ~ 3)) {
        let token = tokenize SPACE (token - "for");
        @{
            "class": #For,
            "value": {
                if (token[1] == "in") {
                    [parseExpr token[0], parseExpr token[2], parseExpr token[3]]
                } else {
                    fault
                }
            }
        }
    } else {
        parseExpr token
    }
);

let parseExpr = fn(source ->
    let tokenList = tokenize SPACE source;
    let token = tokenList[len tokenList  - 1] |> trim;
    let token = {
        // Number 64-bit float;
        if (token as number) {
            @{ "class": #Value, "value": it };

        // Type signature
        } else if (token as signature) {
            @{ "class": #Value, "value": it };

        // Expression that override other operator
        } else if (token[0] == "(" & (token[len token - 1] == ")")) {
            token[1 ~ (len token - 1)] |> trim |> parseExpr;

        // Code block that includes plural statement
        } else if (token[0] == "{" & (token[len token - 1] == "}")) {
            token[1 ~ (len token - 1)] |> trim |> parseBlock;

        // List that can handle many different typed value
        } else if (token[0] == "[" & (token[len token - 1] == "]")) {
            @{ "class": #List, "value": map parseExpr (tokenize [","] token[1 ~ (len token - 1)]) };

        // Text
        } else if (token[0] == "\"" & (token[len token - 1] == "\"")) {
            @{ "class": #Value, "value": token[1 ~ (len token - 1)] };

        // Lambda abstract that is true formula
        } else if (token[0] == "λ" & token["."]) {
            let token = token - "λ" / ".";
            let [args, body] = [token[0], join token[1 ~ len(token)] "."];
            @{ "class": #Lambda, "value": [args, (parseExpr body)] };

        // Lambda abstract using back-slash instead
        } else if (token[0] == "\\" & token["."]) {
            let token = token - "\\" / ".";
            let [args, body] = [token[0], join token[1 ~ len(token)] "."];
            @{ "class": #Lambda, "value": [args, (parseExpr body)] };

        // Symbol
        } else {
           @{ "class": #Symbol, "value": token }
        }
    };
    if (len tokenList >= 2 & tokenList[len tokenList - 2]) {
        let hasLhs = λx.parseExpr(join tokenList[0 ~ (len tokenList - x)] " ");
        match (trim it) {
            "+"  => @{ "class": #Add,    "value": [hasLhs 2, token] },
            "-"  => @{ "class": #Sub,    "value": [hasLhs 2, token] },
            "*"  => @{ "class": #Mul,    "value": [hasLhs 2, token] },
            "/"  => @{ "class": #Div,    "value": [hasLhs 2, token] },
            "%"  => @{ "class": #Mod,    "value": [hasLhs 2, token] },
            "^"  => @{ "class": #Pow,    "value": [hasLhs 2, token] },
            "==" => @{ "class": #Equal,  "value": [hasLhs 2, token] },
            "as" => @{ "class": #As,     "value": [hasLhs 2, token] },
            "::" => @{ "class": #Access, "value": [hasLhs 2, token] },
            _    => @{ "class": #Apply,  "value": [hasLhs 1, token] }
        }
    } else {
        token
    }
);

let tokenize = fn(delimiter, source ->
    let [tokens, current] = [[], ""];
    let [nest, quote] = [0] * 2;

    for c in (source as list) {
        match c {
            "(" | "[" | "{" => {
                if (quote == 0) {
                    current += c;
                    nest += 1;
                }
            },
            ")" | "]" | "}" => {
                if (quote == 0) {
                    current += c;
                    nest -= 1;
                }
            },
            "\"" | "\'" | "\`" => {
                let quote = { if (quote == 1) 0 else 1 };
                current += c;
            },
            _ => {
                if (delimiter :: [c]) {
                    if ((nest == 0) & (quote == 0)) {
                        if (current != "") {
                            tokens += [current];
                            let current = "";
                        }
                    } else {
                        current += c;
                    }
                } else {
                    current += c;
                }
            }
        }
    };

    if (current != "") {
        let tokens = tokens + [current];
    };

    tokens
);

let valueShow = fn(x ->
    match type(x) {
        #Value => {
            let val = x.value;
            match (type val) {
                list => map valueShow val,
                text => f"\"{val}\"",
                _ => val
            }
        },
        _ => x
    }
);

print "LamLam\n";
let [scope, line] = [@{}, 1];
while 1 {
    let prompt = justRight line 3 "0";
    if evalExpr(scope, parseBlock(input f"[{prompt}]> ")) {
        let [scope, result] = it;
        print f"=> {valueShow result}\n"
    } else {
        print f"=> Fault: {err}\n"
    };
    line += 1
}
