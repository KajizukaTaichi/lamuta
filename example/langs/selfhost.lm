load std;

let evaluate = fn(x ->
    let ast = x;
    match (type ast) {
        #Add => {
            let terms = map self ast.value;
            let [a, b] = [terms[0].value, terms[1].value];
            @{ "class": #Value, "value": a + b }
        },
        #Sub => {
            let terms = map self ast.value;
            let [a, b] = [terms[0].value, terms[1].value];
            @{ "class": #Value, "value": a - b }
        },
        #Mul => {
            let terms = map self ast.value;
            let [a, b] = [terms[0].value, terms[1].value];
            @{ "class": #Value, "value": a * b }
        },
        #Div => {
            let terms = map self ast.value;
            let [a, b] = [terms[0].value, terms[1].value];
            @{ "class": #Value, "value": a / b }
        },
        _ => ast
    }
);

let parse = fn(source ->
    let tokenList = tokenize source;
    let token = tokenList[len tokenList  - 1];
    let token = { 
        if (token as number) {
            @{ "class": #Value, "value": it }
        } else if (token[0] == "(" & (token[len token - 1] == ")")) {
            self token[1 ~ (len token - 1)]
        } else if (token[0] == "\"" & (token[len token - 1] == "\"")) {
            @{ "class": #Value, "value": token[1 ~ (len token - 1)] }
        } else if (token[0] == "λ" & token["."]) {
            let [args, body] = token - "λ" / ".";
            @{ "class": #Value, "value": fn(x -> self body) }
        } else {
           @{ "class": #Symbol, "value": it }
        }
    };
    if (len tokenList >= 2 & tokenList[len tokenList - 2]) {
        let hasLhs = \x.parse(join tokenList[0 ~ (len tokenList - x)] " ");
        let operator = trim it;
        match operator {
            "+" => @{ "class": #Add, "value": [hasLhs 2, token] },
            "-" => @{ "class": #Sub, "value": [hasLhs 2, token] },
            "*" => @{ "class": #Mul, "value": [hasLhs 2, token] },
            "/" => @{ "class": #Div, "value": [hasLhs 2, token] },
            _ =>  @{ "class": #Apply, "value": [hasLhs 1, token] }
        }
    } else {
        token
    }
);

let tokenize = fn(source ->
    let tokens = [];
    let current = "";
    let nest = 0;
    let quote = 0;

    for c in (source as list) {
        match c {
            "(" | "[" | "{" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest + 1;
                }
            },
            ")" | "]" | "}" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest - 1;
                }
            },
            " " | "　" => {
                if ((nest == 0) & (quote == 0)) {
                    if (current != "") {
                        let tokens = tokens + [current];
                        let current = "";
                    }
                } else {
                    let current = current + c;
                }
            },
            "\"" => {
                let quote = { if (quote == 1) 0 else 1 };
                let current = current + c;
            },
            _ => {
                let current = current + c;
            }
        }
    };

    if (current != "") {
        let tokens = tokens + [current];
    };

    tokens
);

print "LamLam\n";
while 1 {
    print evaluate parse(input ">>> "), "\n"
}