load std;

let evaluate = fn(e, x ->
    let [scope, ast] = [e, x];
    match (type ast) {
        #Symbol => {
            [scope, scope[ast.value]]
        },
        #Add => {
            let [[scope, a], [scope, b]] = map (evaluate scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value + b.value }]
        },
        #Sub => {
            let [[scope, a], [scope, b]] = map (evaluate scope) ast.value;
            [scope,@{ "class": #Value, "value": a.value - b.value }]
        },
        #Mul => {
            let [[scope, a], [scope, b]] = map (evaluate scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value * b.value }]
        },
        #Div => {
            let [[scope, a], [scope, b]] = map (evaluate scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value / b.value }]
        },
        #Mod => {
            let [[scope, a], [scope, b]] = map (evaluate scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value % b.value }]
        },
        #Pow => {
            let [[scope, a], [scope, b]] = map (evaluate scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value ^ b.value }]
        },
        _ => [scope, ast]
    }
);

let parse = fn(source ->
    let tokenList = tokenize source;
    let token = tokenList[len tokenList  - 1];
    let token = { 
        if (token as number) {
            @{ "class": #Value, "value": it }
        } else if (token[0] == "(" & (token[len token - 1] == ")")) {
            self token[1 ~ (len token - 1)]
        } else if (token[0] == "\"" & (token[len token - 1] == "\"")) {
            @{ "class": #Value, "value": token[1 ~ (len token - 1)] }
        } else if (token[0] == "λ" & token["."]) {
            let [args, body] = token - "λ" / ".";
            @{ "class": #Value, "value": fn(x -> self body) }
        } else {
           @{ "class": #Symbol, "value": it }
        }
    };
    if (len tokenList >= 2 & tokenList[len tokenList - 2]) {
        let hasLhs = \x.parse(join tokenList[0 ~ (len tokenList - x)] " ");
        match (trim it) {
            "+" => @{ "class": #Add, "value": [hasLhs 2, token] },
            "-" => @{ "class": #Sub, "value": [hasLhs 2, token] },
            "*" => @{ "class": #Mul, "value": [hasLhs 2, token] },
            "/" => @{ "class": #Div, "value": [hasLhs 2, token] },
            "%" => @{ "class": #Mod, "value": [hasLhs 2, token] },
            "^" => @{ "class": #Pow, "value": [hasLhs 2, token] },
            _ => @{ "class": #Apply, "value": [hasLhs 1, token] }
        }
    } else {
        token
    }
);

let tokenize = fn(source ->
    let tokens = [];
    let current = "";
    let nest = 0;
    let quote = 0;

    for c in (source as list) {
        match c {
            "(" | "[" | "{" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest + 1;
                }
            },
            ")" | "]" | "}" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest - 1;
                }
            },
            " " | "　" => {
                if ((nest == 0) & (quote == 0)) {
                    if (current != "") {
                        let tokens = tokens + [current];
                        let current = "";
                    }
                } else {
                    let current = current + c;
                }
            },
            "\"" => {
                let quote = { if (quote == 1) 0 else 1 };
                let current = current + c;
            },
            _ => {
                let current = current + c;
            }
        }
    };

    if (current != "") {
        let tokens = tokens + [current];
    };

    tokens
);

print "LamLam\n";
let scope = @{};
while 1 {
    let [scope, value] = evaluate(scope, parse(input ">>> "));
    print value, "\n"
}