load std;

let evalExpr = fn(e, x ->
    let [scope, ast] = [e, x];
    match (type ast) {
        #Symbol => {
            [scope, scope[ast.value]]
        },
        #Apply => {
            let [[scope, func], [scope, value]] = map (evalExpr scope) ast.value;
            let [[arg, body], funcScope] = [func.value, scope];
            let body = betaReduct(arg, value, body);
            evalExpr funcScope body
        },
        #Add => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value + b.value }]
        },
        #Sub => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope,@{ "class": #Value, "value": a.value - b.value }]
        },
        #Mul => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value * b.value }]
        },
        #Div => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value / b.value }]
        },
        #Mod => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value % b.value }]
        },
        #Pow => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value ^ b.value }]
        },
        _ => [scope, ast]
    }
);

let betaReduct = fn(x, y, z ->
    let [from, to, ast] = [x, y, z];
    match (type ast) {
        #Apply | #Add | #Sub | #Mul | #Div | #Mod | #Pow => {
            @{ "class": type ast, "value": map (betaReduct from to) ast.value }
        },
        #Symbol => {
            if (ast.value == from) {
                @{ "class": type to, "value": to.value }
            } else {
                ast
            }
        },
        #Lambda => {
            let [args, body] = ast.value;
            @{ "class": type ast, "value": [args, {
                if (args == from) 
                    body 
                else 
                    (betaReduct from to) body
            }] }
        },
        _ => ast
    }
);

let parseExpr = fn(source ->
    let tokenList = tokenize source;
    let token = tokenList[len tokenList  - 1];
    let token = { 
        if (token as number) {
            @{ "class": #Value, "value": it }
        } else if (token[0] == "(" & (token[len token - 1] == ")")) {
            self token[1 ~ (len token - 1)]
        } else if (token[0] == "\"" & (token[len token - 1] == "\"")) {
            @{ "class": #Value, "value": token[1 ~ (len token - 1)] }
        } else if (token[0] == "λ" & token["."]) {
            let token = token - "λ" / ".";
            let [args, body] = [token[0], join token[1 ~ len(token)] "."];
            @{ "class": #Lambda, "value": [args, (parseExpr body)] } 
        } else if (token[0] == "\\" & token["."]) {
            let token = token - "\\" / ".";
            let [args, body] = [token[0], join token[1 ~ len(token)] "."];
            @{ "class": #Lambda, "value": [args, (parseExpr body)] } 
        } else {
           @{ "class": #Symbol, "value": token }
        }
    };
    if (len tokenList >= 2 & tokenList[len tokenList - 2]) {
        let hasLhs = λx.parseExpr(join tokenList[0 ~ (len tokenList - x)] " ");
        match (trim it) {
            "+" => @{ "class": #Add, "value": [hasLhs 2, token] },
            "-" => @{ "class": #Sub, "value": [hasLhs 2, token] },
            "*" => @{ "class": #Mul, "value": [hasLhs 2, token] },
            "/" => @{ "class": #Div, "value": [hasLhs 2, token] },
            "%" => @{ "class": #Mod, "value": [hasLhs 2, token] },
            "^" => @{ "class": #Pow, "value": [hasLhs 2, token] },
            _ => @{ "class": #Apply, "value": [hasLhs 1, token] }
        }
    } else {
        token
    }
);

let tokenize = fn(source ->
    let tokens = [];
    let current = "";
    let nest = 0;
    let quote = 0;

    for c in (source as list) {
        match c {
            "(" | "[" | "{" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest + 1;
                }
            },
            ")" | "]" | "}" => {
                if (quote == 0) {
                    let current = current + c;
                    let nest = nest - 1;
                }
            },
            " " | "　" => {
                if ((nest == 0) & (quote == 0)) {
                    if (current != "") {
                        let tokens = tokens + [current];
                        let current = "";
                    }
                } else {
                    let current = current + c;
                }
            },
            "\"" => {
                let quote = { if (quote == 1) 0 else 1 };
                let current = current + c;
            },
            _ => {
                let current = current + c;
            }
        }
    };

    if (current != "") {
        let tokens = tokens + [current];
    };

    tokens
);

print "LamLam\n";
let scope = @{};
while 1 {
    let [scope, value] = evalExpr(scope, parseExpr(input ">>> "));
    print value, "\n"
}