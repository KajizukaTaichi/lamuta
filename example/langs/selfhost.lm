load std;

const SPACE: list = [" ", "　", "\n", "\t", "\r"];

let evalExpr = fn(e, x ->
    let [scope, ast] = [e, x];
    match (type ast) {
        #Let => {
            let name = ast.value[0];
            let [scope, val] = evalExpr scope ast.value[1];
            if (type name == #Symbol) {
                scope[name.value] := val;
                [scope, val]
            } else {
                fault "the program is not able to parse. check out is the syntax correct"
            }
        },
        #If => {
            if { let [scope, cond] = evalExpr scope ast.value[0] }
                evalExpr scope ast.value[1]
            else if ast.value[2] 
                evalExpr scope it
            else 
                [scope, @{ "class": #Value, "value": null }]
            
        },
        #Block => {
            let result = @{ "class": #Value, "value": null };
            for i in ast.value {
                [scope, result] := evalExpr(scope, i);
            };
            [scope, result]
        },
        #Symbol => {
            [scope, scope[ast.value]]
        },
        #List => {
            let result = [];
            for i in ast.value {
                [scope, val] := evalExpr(scope, i);
                result += [val]
            };
            [scope, @{ "class": #Value, "value": result }]
        },
        #Apply => {
            let [[scope, func], [scope, value]] = map (evalExpr scope) ast.value;
            let [[arg, body], funcScope] = [func.value, scope];
            let body = betaReduct(arg, value, body);
            [scope, evalExpr funcScope body :: 1]
        },
        #Add => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value + b.value }]
        },
        #Sub => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope,@{ "class": #Value, "value": a.value - b.value }]
        },
        #Mul => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value * b.value }]
        },
        #Div => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value / b.value }]
        },
        #Mod => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value % b.value }]
        },
        #Pow => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value ^ b.value }]
        },
        #Equal => {
            let [[scope, a], [scope, b]] = map (evalExpr scope) ast.value;
            [scope, @{ "class": #Value, "value": a.value == b.value }]
        },
        _ => [scope, ast]
    }
);

let betaReduct = fn(x, y, z ->
    let [from, to, ast] = [x, y, z];
    match (type ast) {
        #Let => {
            @{ "class": #Let, "value": [ast.value[0], betaReduct from to ast.value[1]] }
        },
        #Add | #Sub | #Mul | #Div | #Mod | #Pow
        | #Apply | #Equal | #Block | #If => {
            @{ "class": type ast, "value": map (betaReduct from to) ast.value }
        },
        #Symbol => { if (ast.value == from) to else ast },
        #Lambda => {
            let [args, body] = ast.value;
            @{
                "class": #Lambda, 
                "value": [args, {
                    if (args == from) 
                        body 
                    else 
                        (betaReduct from to) body
                }]
            }
        },
        _ => ast
    }
);

let parseBlock = fn(source -> 
    let [token, block] = [trim source, []];
    for line in (tokenize [";"] token) {
        if (parseStmt line) {
            block += [it]
        }
    };
    @{ "class": #Block, "value": block }
); 

let parseStmt = fn(source -> 
    let token = trim source;
    if (token["let"] == (0 ~ 3)) {
        let token = token - "let" / "=";
        @{ "class": #Let, "value": map parseExpr [token[0], join token[1 ~ len(token)] "="] }
    } else if (token["if"] == (0 ~ 2)) {
        let token = tokenize SPACE (token - "if");
        @{ 
            "class": #If, 
            "value": { 
                if (token :: ["else"]) [
                    parseExpr token[0], 
                    parseExpr (join token[1 ~ (it as list :: 0)] SPACE[0]), 
                    parseBlock (join token[(it as list :: 0) + 1 ~ len(token)] SPACE[0])
                ] else [
                    parseExpr token[0], 
                    parseExpr (join token[1 ~ len(token)] SPACE[0])
                ]
            }
        }
    } else {
        parseExpr token
    }
); 

let parseExpr = fn(source ->
    let tokenList = tokenize SPACE source;
    let token = tokenList[len tokenList  - 1] |> trim;
    let token = { 
        if (token as number) {
            @{ "class": #Value, "value": it }
        } else if (token[0] == "(" & (token[len token - 1] == ")")) {
            token[1 ~ (len token - 1)] |> trim |> parseExpr
        } else if (token[0] == "{" & (token[len token - 1] == "}")) {
            token[1 ~ (len token - 1)] |> trim |> parseBlock
        } else if (token[0] == "[" & (token[len token - 1] == "]")) {
            @{ "class": #List, "value": map parseExpr (tokenize [","] token[1 ~ (len token - 1)]) }
        } else if (token[0] == "\"" & (token[len token - 1] == "\"")) {
            @{ "class": #Value, "value": token[1 ~ (len token - 1)] }
        } else if (token[0] == "λ" & token["."]) {
            let token = token - "λ" / ".";
            let [args, body] = [token[0], join token[1 ~ len(token)] "."];
            @{ "class": #Lambda, "value": [args, (parseExpr body)] } 
        } else if (token[0] == "\\" & token["."]) {
            let token = token - "\\" / ".";
            let [args, body] = [token[0], join token[1 ~ len(token)] "."];
            @{ "class": #Lambda, "value": [args, (parseExpr body)] } 
        } else {
           @{ "class": #Symbol, "value": token }
        }
    };
    if (len tokenList >= 2 & tokenList[len tokenList - 2]) {
        let hasLhs = λx.parseExpr(join tokenList[0 ~ (len tokenList - x)] " ");
        match (trim it) {
            "+" => @{ "class": #Add, "value": [hasLhs 2, token] },
            "-" => @{ "class": #Sub, "value": [hasLhs 2, token] },
            "*" => @{ "class": #Mul, "value": [hasLhs 2, token] },
            "/" => @{ "class": #Div, "value": [hasLhs 2, token] },
            "%" => @{ "class": #Mod, "value": [hasLhs 2, token] },
            "^" => @{ "class": #Pow, "value": [hasLhs 2, token] },
            "==" => @{ "class": #Equal, "value": [hasLhs 2, token] },
            _ => @{ "class": #Apply, "value": [hasLhs 1, token] }
        }
    } else {
        token
    }
);

let tokenize = fn(delimiter, source ->
    let [tokens, current] = [[], ""];
    let [nest, quote] = [0] * 2;

    for c in (source as list) {
        match c {
            "(" | "[" | "{" => {
                if (quote == 0) {
                    current += c;
                    nest += 1;
                }
            },
            ")" | "]" | "}" => {
                if (quote == 0) {
                    current += c;
                    nest -= 1;
                }
            },
            "\"" | "\'" | "\`" => {
                let quote = { if (quote == 1) 0 else 1 };
                current += c;
            },
            _ => {
                if (delimiter :: [c]) {
                    if ((nest == 0) & (quote == 0)) {
                        if (current != "") {
                            tokens += [current];
                            let current = "";
                        }
                    } else {
                        current += c;
                    } 
                } else {
                    current += c;
                }
            }
        }
    };

    if (current != "") {
        let tokens = tokens + [current];
    };

    tokens
);

print "LamLam\n";
let scope = @{};
while 1 {
    if evalExpr(scope, parseBlock(input ">>> ")) {
        let [scope, result] = it;
        print result.value, "\n"
    } else {
        print "Fault: ", err, "\n"
    }
}